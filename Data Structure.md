# 数据结构

## 线性数据结构

### 一、数组、列表、线性表（广义表）

**数组（Array）** 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。

我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。

**广义表(Lists)**是线性表的一种推广，即广义表中放松对表元素的原子限制，容许它们具有其自身结构。

>假如数组的长度为 n。
>访问：O（1）//访问特定位置的元素
>插入：O（n）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时
>删除：O（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时

### 二、链表

**链表（Linked List）** 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。它将<u>下一个元素的指向作为每个节点的一部分存储起来</u>，通过逻辑连接每个节点

> 假如链表中有n个元素。
> 访问：O（n）//访问特定位置的元素
> 插入删除：O（1）//必须要要知道插入元素的位置

#### 链表的分类

- 单链表

**单链表** 单向链表只有一个方向，每个结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null

- 双向链表

**双向链表** 每个节点包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。

- 循环链表

**循环链表** 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。

- 双向循环链表

**双向循环链表** 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。

### 三、栈

**栈 (Stack)** 只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 **后进先出（LIFO, Last In First Out）** 的原理运作。**在栈中，push 和 pop 的操作都发生在栈顶。**

栈常用一维数组或链表来实现，用数组实现的栈叫作 **顺序栈** ，用链表实现的栈叫作 **链式栈** 。

> 假设堆栈中有n个元素。
> 访问：O（n）//最坏情况
> 插入删除：O（1）//顶端插入和删除元素

#### 栈的应用

- 浏览器的回退和前进
- 检查符号是否出现
- 反转字符串
- 维护函数调用

### 四、队列

**队列（Queue）** 是 **先进先出 (FIFO，First In, First Out)** 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 **顺序队列** ，用链表实现的队列叫作 **链式队列** 。**队列只允许在后端（rear）进行插入操作也就是入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue**

队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。

> 假设队列中有n个元素。
> 访问：O（n）//最坏情况
> 插入删除：O（1）//后端插入前端删除元素

#### 队列的分类

- 单队列

单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 **顺序队列（数组实现）** 和 **链式队列（链表实现）**。

**顺序队列存在_“假溢出”_的问题也就是明明有位置却不能添加的情况。**

![Fake Overflow](https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/seq-queue-false-overflow.png)

- 循环队列

**为了解决假溢出的问题**，出现了**循环队列**，循环队列的特点就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。

顺序队列中，我们说 `front==rear` 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种

1. 可以设置一个标志变量 `flag`,当 `front==rear` 并且 `flag=0` 的时候队列为空，当`front==rear` 并且 `flag=1` 的时候队列为满。

2. 队列为空的时候就是 `front==rear` ，队列满的时候，我们保证数组还有**一个空闲的位置**，**rear 就指向这个空闲位置**，如下图所示，那么现在判断队列是否为满的条件就是：`(rear+1) % QueueSize==front` 。

- 双端队列

**双端队列 (Deque)** 是一种在队列的两端都可以进行插入和删除操作的队列，相比单队列来说更加灵活。可以**用其实现栈**的所有操作

一般来说，我们可以对双端队列进行 `addFirst`、`addLast`、`removeFirst` 和 `removeLast` 操作。

- 优先队列

**优先队列 (Priority Queue)** 从底层结构上来讲并非线性的数据结构，它一般是由堆来实现的。

1. 在每个元素入队时，优先队列会将新元素其插入堆中并调整堆。
2. 在队头出队时，优先队列会返回堆顶元素并调整堆。

总而言之，不论我们进行什么操作，优先队列都能按照**某种排序方式**进行一系列堆的相关操作，从而保证整个集合的**有序性**。

虽然优先队列的底层并非严格的线性结构，但是在我们使用的过程中，我们是感知不到**堆**的，从使用者的眼中优先队列可以被认为是一种线性的数据结构：一种**会自动排序的线性队列**。

#### 队列的应用

当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。

- **阻塞队列：** 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。
- **线程池中的请求/任务队列：** 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如：`FixedThreadPool` 使用无界队列 `LinkedBlockingQueue`。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出`java.util.concurrent.RejectedExecutionException` 异常。
- 栈：**双端队列天生便可以实现栈的全部功能**（`push`、`pop` 和 `peek`），并且在Deque接口中已经实现了相关方法。Stack 类已经和 Vector 一样被遗弃，现在在 Java 中普遍使用双端队列（Deque）来实现栈。
- Linux 内核进程队列（按优先级排队）
- 现实生活中的派对，播放器上的播放列表;
- 消息队列

- ...

## 图

对于**线性关系**来说：

- 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。
- 树形数据结构的元素之间有着明显的层次关系。

但是，图形结构的元素之间的关系是**任意**的。

### 基本概念

#### 一、顶点

图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）

#### 二、边

顶点之间的关系用边表示。

#### 三、度

度表示一个顶点包含多少条边，在有向图中，还分为**出度**和**入度**，出度表示从**该顶点出去的边的条数**，入度表示**进入该顶点的边的条数**。

#### 四、无向图和有向图

边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A 是 B 的同学，那么 B 也肯定是 A 的同学，那么在表示 A 和 B 的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。

#### 五、无权图和带权图

对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。

对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的**每一条边一个数值表示权值，代表关系的强度**

### 图的存储

#### 邻接矩阵

邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。

如果第 i 个顶点和第 j 个顶点之间有关系，且关系权值为 n，则 `A[i][j]=n` 。

在无向图中，我们只关心关系的有无，所以当顶点 i 和顶点 j 有关系时，`A[i][j]`=1，当顶点 i 和顶点 j 没有关系时，`A[i][j]`=0。

值得注意的是：**无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点 i 和顶点 j 有关系，则顶点 j 和顶点 i 必有关系。**

邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，

![有向图](https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/adjacency-matrix-representation-of-directed-graph.png)

#### 邻接表

针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—**邻接表** 。

邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点 Vi，把所有邻接于 Vi 的顶点 Vj 链成一个单链表，这个单链表称为顶点 Vi 的 **邻接表**。

![有向图邻接表](https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/adjacency-list-representation-of-directed-graph.png)

大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：

- 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为 7，邻接表存储的元素个数为 14。
- 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为 8，邻接表存储的元素个数为 8。

### 图的搜索

#### 广度优先

广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——**队列**

1. **初始状态**：将源顶点放入队列
2. 取出队首节点，找到队首节点的（未访问过的）后继顶点加入队列
3. 重复第二步

#### 深度优先

和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——**栈** 。

1. **初始状态**：将要搜索的源顶点放入栈中
2. 取出栈顶元素，将栈顶元素的（未访问过的）后继节点放入栈中
3. 重复第二步

## 树

树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。

一棵树具有以下特点：

1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。
2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。
3. 一棵树不包含回路。

### 常见概念

- **节点**：树中的每个元素都可以统称为节点。

* **根节点**：顶层节点或者说没有父节点的节点。上

* **父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点。

* **子节点**：一个节点含有的子树的根节点称为该节点的子节点。

* **兄弟节点**：具有相同父节点的节点互称为兄弟节点。。

* **叶子节点**：没有子节点的节点。

* **节点的高度**：该节点到叶子节点的最长路径所包含的边数。

* **节点的深度**：根节点到该节点的路径所包含的边数

* **节点的层数**：节点的深度+1。

* **树的高度**：根节点的高度。

### 树的分类

### 二叉树的分类

**二叉树**（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。

**二叉树** 的分支通常被称作“**左子树**”或“**右子树**”。并且，**二叉树** 的分支具有左右次序，不能随意颠倒。

**二叉树** 的第 i 层至多拥有 `2^(i-1)` 个节点，深度为 k 的二叉树至多总共有 `2^(k+1)-1` 个节点（满二叉树的情况），至少有 2^(k) 个节点

#### 满二叉树

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 **满二叉树**。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 **满二叉树**。

#### 完全二叉树

除最后一层外，若其余层都是满的，并且最后一层要么是满的，要么是在右边缺少连续若干节点，则这个二叉树就是 **完全二叉树** 。

完全二叉树有一个很好的性质：**父结点和子节点的序号有着对应关系。**

细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。

#### 平衡二叉树

**平衡二叉树** 是一棵二叉排序树，且具有以下性质：

1. 可以是一棵空树
2. 如果不是空树，它的**左右两个子树的高度差的绝对值不超过 1**，并且**左右两个子树都是一棵平衡二叉树**。

平衡二叉树的常用实现方法有 **红黑树**、**AVL 树**、**替罪羊树**、**加权平衡树**、**伸展树** 等。

### 二叉树的存储

#### 链式存储

和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。

每个节点包括三个属性：

- 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。
- 左节点指针 left
- 右节点指针 right。

可是 JAVA 没有指针啊

#### 顺序存储

顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中<u>下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。</u>

### 二叉树的遍历

#### 前序遍历

二叉树的先序遍历，就是

1. 先输出根结点
2. 再遍历左子树
3. 最后遍历右子树

遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。

#### 中序遍历

二叉树的中序遍历，就是

1. 先递归中序遍历左子树
2. 再输出根结点的值
3. 再递归中序遍历右子树

大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间

#### 后序遍历

二叉树的后序遍历

1. 先递归后序遍历左子树
2. 递归后序遍历右子树
3. 最后输出根结点的值

### 二叉搜索树（Binary Search Tree）

使用**二分查找**的思想，将数组进行二分排序形成的树。它具有以下特点

* **左**子树上所有结点的值均**小于或等于**它的根结点的值。
* **右**子树上所有结点的值均**大于或等于**它的根结点的值。
* 左、右子树也分别为二叉排序树。

但是在某些情况下，二叉搜索树会退化为线性结构

![退化的二叉搜索树](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/6/1602b6014331f371~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

### 红黑树

* 每个节点非红即黑；

* 根节点总是黑色的；

* 每个叶子节点都是黑色的空节点（NIL 节点）；

* 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；

* 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

而在插入和删除时，红黑树的规则有可能会被打破。为了维持规则，我们要进行一些操作来对红黑树进行调整。

#### 红黑树的操作

* 变色

将节点从一个颜色改变为另一个颜色

* 左旋转

**逆时针**旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异

![左旋转](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/6/1602b60230926ead~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

* 右旋转

**顺时针**旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

![右旋转](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/6/1602b6024ce2b0c4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

## 堆

堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。

简单来说，就是**每个节点经过排序的树**

- 很多博客说堆是完全二叉树，其实并非如此，**堆不一定是完全二叉树**，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。

- （**二叉**）堆是一个数组，它可以被看成是一个 **近似的完全二叉树**。——《算法导论》第三版

### 堆的用途

当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。

有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 `O(nlog(n))`，查找最大值或者最小值时间复杂度都是 `O(1)`，但是，涉及到更新（插入或删除）数据时，时间复杂度为 `O(n)`，即使是使用复杂度为 `O(log(n))` 的二分法找到要插入或者删除的数据，在移动数据时也需要 `O(n)` 的时间复杂度。

**相对于有序数组而言，堆的主要优势在于_插入和删除数据_效率较高。** 因为堆是基于完全二叉树实现的，所以在插入和删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 `O(log(n))`，相比有序数组的 `O(n)`，效率更高。

### 堆的分类

堆分为 **最大堆** 和 **最小堆**。二者的区别在于节点的排序方式。

- **最大堆**：堆中的每一个节点的值都大于等于子树中所有节点的值
- **最小堆**：堆中的每一个节点的值都小于等于子树中所有节点的值

### 堆的存储

之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 `2*i`，右子节点序号为 `2*i+1`）。

![堆的存储](https://javaguide.cn/assets/%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8-03237dbe.png)

### 堆的操作

#### 插入

 1. **将要插入的元素放到最后**

 2. ##### **从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换**

#### 删除堆顶元素并堆化

​	根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。

删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"**堆化**"，堆化的方法分为两种：

- 一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。
- 另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。

---

* 自底向上堆化

1. 首先删除堆顶元素，使得数组中下标为 1 的位置空出。
2. 比较根结点的左子节点和右子节点，也就是下标为 2,3 的数组元素，将较大的元素填充到根结点(下标为 1)的位置。
3. 一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部

这样就相当于完成了自底向上的堆化，但是，**在_二叉树的叶子节点_会出现没有数据的“气泡”。从而导致存储空间的浪费**

* 自顶向下堆化

1. 这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。
2. 将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。

这样的操作就不会产生气泡，是更好的操作

#### 堆排序

1. 建堆

   将无序数组转换为二叉树，并对所有非叶节点（父节点）进行自顶向下堆化

2. 排序

   由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个**最大的堆顶元素放至数组末尾**，并对剩下的元素进行堆化即可。

​	